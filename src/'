//! Compile the brain fuck AST into

use crate::{parser::Instruction, tokenizer::Op};
use core::slice;
use iced_x86::code_asm::*;

pub struct JIT {
    code: Vec<u8>,
    // memory that will be handled by the code,
    // data pointer will point to half of this vector
    memory: Box<Vec<u8>>,
    data: Box<u8>,
    memory_pointer: u64,
    data_pointer: u64,
}

impl JIT {
    pub fn new() -> anyhow::Result<Self> {
        let memory = Box::new(Vec::with_capacity(4 * 1024));
        let data = Box::new(0);
        let memory_pointer = &memory[memory.len() / 2] as *const u8 as u64;
        // not sure about that
        let data_pointer = data.as_ref() as *const u8 as u64;

        let jit = JIT {
            code: vec![],
            memory,
            data,
            memory_pointer,
            data_pointer,

        };

        //c.ret()?;

        //c.mov(rax, 60u64)?;
        //c.xor(rdi, rdi)?;
        //c.syscall()?;

        Ok(jit)
    }

    pub fn execute(&mut self, instructions: Vec<Instruction>) {
        let mut c = CodeAssembler::new(64).unwrap();

        for instruction in instructions {
            self.append_code(instruction, &mut c);
        }

        unsafe {
            let max_code_size = 4 * 1024;
            let code_pointer = nix::sys::mman::mmap(
                None,
                (max_code_size).try_into().unwrap(),
                nix::sys::mman::ProtFlags::PROT_READ
                    | nix::sys::mman::ProtFlags::PROT_WRITE
                    | nix::sys::mman::ProtFlags::PROT_EXEC,
                nix::sys::mman::MapFlags::MAP_PRIVATE | nix::sys::mman::MapFlags::MAP_ANONYMOUS,
                -1,
                0,
            )
            .unwrap();

            let bytes = c.assemble(code_pointer as u64).unwrap();
            let code_size = bytes.len();

            Self::print_code(&bytes);

            let code = slice::from_raw_parts_mut(&mut *(code_pointer as *mut u8), code_size);
            code.copy_from_slice(&bytes);

            //let init_code_pointer = &code[0] as *const u8 as *mut core::ffi::c_void;
            //let init_fun_pointer = init_code_pointer as *const fn();
            //let fun = unsafe { *init_fun_pointer };

            let fun: extern "C" fn() = core::mem::transmute(code_pointer);
            fun();
        }
    }

    fn get_pointed_memory(&self) -> u64 {
        self.memory_pointer + self.data_pointer
    }

    fn op_code(&self, op: Op, c: &mut CodeAssembler) {
        match op {
            Op::IncrementDataPointer => todo!(),
            Op::DecrementDataPointer => todo!(),
            Op::Increment => {
                //c.mov(rax, self.data_pointer).unwrap();
                //c.inc(1).unwrap();
                //c.mov(self.data_pointer, rax).unwrap();
            }
            Op::Decrement => todo!(),
            Op::Output => {
                c.mov(rax, 1u64).unwrap();
                c.mov(rdi, 1u64).unwrap();
                c.mov(rsi, self.get_pointed_memory()).unwrap();
                c.mov(rdx, 1u64).unwrap();
                c.syscall().unwrap();
            }
            Op::Input => todo!(),
        }
    }

    fn append_code(&self, instruction: Instruction, c: &mut CodeAssembler) {
        match instruction {
            Instruction::Op { name, instruction } => {
                // TODO lable
                self.op_code(instruction, c);
            }
            Instruction::Branch {
                name,
                instruction,
                name_jump_to,
            } => todo!(),
            Instruction::End { name: _name } => {
                c.ret().unwrap();
            }
        }
    }

    fn print_code(bytes: &Vec<u8>) {
        use iced_x86::*;

        let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);

        // Formatters: Masm*, Nasm*, Gas* (AT&T) and Intel* (XED).
        // For fastest code, see `SpecializedFormatter` which is ~3.3x faster. Use it if formatting
        // speed is more important than being able to re-assemble formatted instructions.
        let mut formatter = NasmFormatter::new();

        // Change some options, there are many more
        formatter.options_mut().set_digit_separator("`");
        formatter.options_mut().set_first_operand_char_index(10);

        // String implements FormatterOutput
        let mut output = String::new();

        // Initialize this outside the loop because decode_out() writes to every field
        let mut instruction = Instruction::default();

        // The decoder also implements Iterator/IntoIterator so you could use a for loop:
        //      for instruction in &mut decoder { /* ... */ }
        // or collect():
        //      let instructions: Vec<_> = decoder.into_iter().collect();
        // but can_decode()/decode_out() is a little faster:
        while decoder.can_decode() {
            // There's also a decode() method that returns an instruction but that also
            // means it copies an instruction (40 bytes):
            //     instruction = decoder.decode();
            decoder.decode_out(&mut instruction);

            // Format the instruction ("disassemble" it)
            output.clear();
            formatter.format(&instruction, &mut output);

            // Eg. "00007FFAC46ACDB2 488DAC2400FFFFFF     lea       rbp,[rsp-100h]"
            println!(" {}", output);
        }
    }
}
